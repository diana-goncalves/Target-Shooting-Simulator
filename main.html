<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Target Shooting Simulator</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <center>
        <canvas id="myCanvas" width="1200" height="400" style="border:solid 2px black">
            Your browser does not support HTML5 Canvas.
        </canvas>
        <div class="wrapper">
            <div class="PB-range-slider-div">
                <p class="slidervalue">Velocidade:</p>
                <input type="range" min="0" max="100" value="50" class="PB-range-slider" id="Vel">
                <p class="slidervalue velValue">50</p>
            </div>

        </div>
    </center>


    <script>
        // GLOBALS
        const canvas = document.querySelector('#myCanvas');
        const ctx = canvas.getContext("2d");
        const velocity = document.querySelector("#Vel");

        const W = canvas.width, H = canvas.height;
        let arrows = new Array(); // arrows (array of objects)
        let angle = 0

        //Sprite
        let player = new Image()
        player.src = "./assets/sprites/Idle.png"
        let framePlayer = 0;
        let frameDelay = 0;
        let mouseIn = false;
        let arm = new Image()
        arm.src = ""

        const bgSky = new Image();
        bgSky.src = './assets/background/1.png'

        const bgFloor = new Image();
        bgFloor.src = './assets/background/2.png'

        const bgGrass = new Image();
        bgGrass.src = './assets/background/3.png'

        const bgCloud = new Image();
        bgCloud.src = './assets/background/4.png'

        let cloudX = 0; // Posição inicial das nuvens

        window.onload = () => {

            velocity.addEventListener("input", (e) => {
                e.preventDefault();

                document.querySelector(".velValue").innerHTML = velocity.value;
            })

            render();
        };

        canvas.addEventListener('click', e => {
            // add a new cannon ball
            arrows.push(new Arrow(velocity.value, angle))
        });

        // Add the event listener for mousemove
        canvas.addEventListener('mousemove', e => {
            //mouse cursor coordinates
            let x = e.offsetX; let y = e.offsetY;

            // update cannon ORIENTATION angle​
            let dx = x - 50;
            let dy = y - (H - 50);
            angle = Math.atan2(dy, dx);
            console.log(angle);

        });

        // add a attack animation
        canvas.addEventListener('mouseenter', e => {
            player.src = "./assets/sprites/Attack.png"
            mouseIn = true
        });

        // add a idle animation
        canvas.addEventListener('mouseleave', e => {
            player.src = "./assets/sprites/Idle.png"
            mouseIn = false
        });


        function render() {
            ctx.clearRect(0, 0, W, H);

            // Desenhar o background em camadas
            ctx.drawImage(bgSky, 0, 0, W, H * 0.9);          // Céu ocupa 90% da altura do canvas
            ctx.drawImage(bgGrass, 0, H * 0.65, W, H * 0.3);  // Grama ocupa 30% da altura, logo abaixo do céu
            ctx.drawImage(bgFloor, 0, H * 0.8, W, H * 0.2);  // Chão ocupa os últimos 20% da altura do canvas

            // Desenhar o jogador
            ctx.drawImage(player, framePlayer, 0, 42, 42, 20, H - 100, 84, 84);

            // Animação do frame do jogador
            if (frameDelay == 5) {
                framePlayer += 42;
                frameDelay = 0;
            } else {
                frameDelay++;
            }

            if (framePlayer == 168) {
                framePlayer = 0;
            }

            // Função de animação das nuvens
            animate();

            // Desenhar o braço e ajustar posição conforme o ângulo
            if (mouseIn) {
                if (angle > 0.7) {
                    arm.src = "./assets/sprites/4.png";
                } else if (angle < 0.7 && angle > 0) {
                    arm.src = "./assets/sprites/3.png";
                } else if (angle < 0 && angle > -0.9) {
                    arm.src = "./assets/sprites/2.png";
                } else if (angle < -0.9) {
                    arm.src = "./assets/sprites/1.png";
                }
                ctx.drawImage(arm, 0, 0, 42, 42, 20, H - 95, 84, 84);
            }

            // Desenhar e atualizar as setas
            arrows.forEach(arrow => {
                arrow.draw();
                arrow.update();
            });

            requestAnimationFrame(render);
        }

        function convertToRad(a) {
            return a / (Math.PI / 180)
        }


        function animate() {
            // Atualizar posição das nuvens para o efeito de movimento
            cloudX -= 0.3;
            if (cloudX <= -bgCloud.width) {
                cloudX = 0; // Reinicia a posição para repetir a imagem
            }

            // Desenha as nuvens animadas
            ctx.drawImage(bgCloud, cloudX, 0, bgCloud.width, H * 1.2); // Primeira repetição
            ctx.drawImage(bgCloud, cloudX + bgCloud.width, 0, bgCloud.width, H * 1.2); // Segunda repetição
            ctx.drawImage(bgCloud, cloudX + 2 * bgCloud.width, 0, bgCloud.width, H * 1.2); // Terceira repetição
        }




        class Arrow {
            constructor(vel, angle) {

                this.raius

                this.x = 50 + 75 * Math.cos(angle)			// initial X position
                this.y = H - 50 + 75 * Math.sin(angle) 	// initial Y position

                this.A = 0.1 		// acceleration (gravity = 0.1 pixels per frame)
                this.R = 5;

                this.dX = vel / 10 * Math.cos(angle) //initial velocity in X
                this.dY = vel / 10 * Math.sin(angle)	//initial velocity in Y
            }
            draw() {
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.R, 0, 2 * Math.PI);
                ctx.fill();
            }

            update() {
                // if circle hits the bottom of the Canvas
                if (this.y > H - this.R) {
                    this.y = H - this.R;
                    this.dX = this.dY = 0; // stop

                }
                else {
                    this.x += this.dX; // update circle X position (uniform motion)
                    this.dY += this.A; // increase circle velocity in Y (accelerated motion)
                    this.y += this.dY; // update circle Y position
                }
            }
        };



    </script>
</body>

</html>
