<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Target Shooting Simulator</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <center>
        <canvas id="myCanvas" width="1400" height="400" style="border:solid 2px black">
            Your browser does not support HTML5 Canvas.
        </canvas>
        <div class="wrapper">
            <div class="PB-range-slider-div">
                <p class="slidervalue">Velocidade:</p>
                <input type="range" min="0" max="100" value="50" class="PB-range-slider" id="Vel">
                <p class="slidervalue velValue">50</p>
            </div>
            
        </div>
    </center>


    <script>
        // GLOBALS
        const canvas = document.querySelector('#myCanvas');
        const ctx = canvas.getContext("2d");
        const velocity = document.querySelector("#Vel");

        const W = canvas.width, H = canvas.height;
        let arrows = new Array(); // arrows (array of objects)
        let angle = 0
        window.onload = () => {

            velocity.addEventListener("input",(e)=>{
            e.preventDefault();

            document.querySelector(".velValue").innerHTML = velocity.value;
            })

            render();
        };

        canvas.addEventListener('click', e => {
            // add a new cannon ball
            arrows.push(new Arrow(velocity.value,angle))
        });

        // Add the event listener for mousemove
        canvas.addEventListener('mousemove', e => {
            //mouse cursor coordinates
            let x = e.offsetX; let y = e.offsetY;

            // update cannon ORIENTATION angleâ€‹
            let dx = x - 50;
            let dy = y - (H - 50);
            angle = Math.atan2(dy, dx);
            console.log(angle);
            
        });


        function render() {
            ctx.clearRect(0, 0, W, H);

            //draw cannon
            ctx.fillStyle = "#457b9d";
            ctx.beginPath();
            ctx.arc(50, H - 25, 20, 0, 2 * Math.PI);
            ctx.fill();

            // use cannon orientation angle to determine final point of the line
            ctx.strokeStyle = "#1d3557";
            ctx.lineWidth = 20;
            ctx.beginPath();
            ctx.moveTo(50, H - 50);
            ctx.lineTo(20 + 75 * Math.cos(angle), H - 50 + 75 * Math.sin(angle));
            ctx.stroke();

            ctx.fillStyle = "#a8dadc";
            ctx.beginPath();
            ctx.arc(50, H - 50, 20, 0, 2 * Math.PI);
            ctx.fill();

            // if (shoot) {
            arrows.forEach(arrow => {
                arrow.draw();
                arrow.update();
            })

            requestAnimationFrame(render);
        }

        function convertToRad(a) {
            return a / (Math.PI/180)   
        }

        


        class Arrow {
            constructor(vel, angle) {

                this.raius

                this.x = 50 + 75 * Math.cos(angle)			// initial X position 
                this.y = H - 50 + 75 * Math.sin(angle) 	// initial Y position 

                this.A = 0.1 		// acceleration (gravity = 0.1 pixels per frame)
                this.R = 5;

                this.dX = vel/10 * Math.cos(angle) //initial velocity in X
                this.dY = vel/10 * Math.sin(angle)	//initial velocity in Y
            }
            draw() {
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.R, 0, 2 * Math.PI);
                ctx.fill();
            }

            update() {
                // if circle hits the bottom of the Canvas
                if (this.y > H - this.R) {
                    this.y = H - this.R; 
                    this.dX = this.dY = 0; // stop

                }
                else {
                    this.x += this.dX; // update circle X position (uniform motion)
                    this.dY += this.A; // increase circle velocity in Y (accelerated motion)
                    this.y += this.dY; // update circle Y position 
                }
            }
        };



    </script>
</body>
</html>