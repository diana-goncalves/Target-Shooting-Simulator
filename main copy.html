<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Target Shooting Simulator</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <center>
        <canvas id="myCanvas" width="1400" height="400" style="border:solid 2px black">
            Your browser does not support HTML5 Canvas.
        </canvas>
        <div class="wrapper">
            <div class="PB-range-slider-div">
                <p class="slidervalue">Velocidade:</p>
                <input type="range" min="0" max="100" value="50" class="PB-range-slider" id="Vel">
                <p class="slidervalue velValue">50</p>
            </div>
            
        </div>
    </center>


    <script>
        // GLOBALS
        const canvas = document.querySelector('#myCanvas');
        const ctx = canvas.getContext("2d");
        const velocity = document.querySelector("#Vel");

        const W = canvas.width, H = canvas.height;
        let arrows = new Array(); // arrows (array of objects)
        let angle = 0

        //Sprite
        let player = new Image()
        player.src = "./sprites/Idle.png"
        let framePlayer = 0;
        let frameDelay = 0;

        let arm = new Image()
        arm.src = "./sprites/1.png"

        window.onload = () => {

            velocity.addEventListener("input",(e)=>{
            e.preventDefault();

            document.querySelector(".velValue").innerHTML = velocity.value;
            })
            render();
        };

        canvas.addEventListener('click', e => {
            // add a new cannon ball
            arrows.push(new Arrow(velocity.value,angle))
        });

        // Add the event listener for mousemove
        canvas.addEventListener('mousemove', e => {
            //mouse cursor coordinates
            let x = e.offsetX; let y = e.offsetY;

            // update cannon ORIENTATION angleâ€‹
            let dx = x - 50;
            let dy = y - (H - 50);
            angle = Math.atan2(dy, dx);
            console.log(angle);
            
        });


        function render() {
            ctx.clearRect(0, 0, W, H);

            ctx.drawImage(player,framePlayer,0,42,42,20,H-100,84,84)

            if (frameDelay == 5) {
                framePlayer+=42;
                frameDelay=0
            } else {
                frameDelay++;
            }

            if (framePlayer==168) {
                framePlayer=0;
            }

            //use cannon orientation angle to determine final point of the line

            if (angle > 0.7) {
                arm.src = "./sprites/4.png"
                ctx.drawImage(arm,0,0,42,42,30,H-100,84,84)
            }else if (angle < 0.7 && angle > 0.2 ) {
                arm.src = "./sprites/3.png"
                ctx.drawImage(arm,0,0,42,42,30,H-100,84,84)
            }else if (angle < 0.2 && angle > -0.2 ) {
                arm.src = "./sprites/2.png"
                ctx.drawImage(arm,0,0,42,42,30,H-100,84,84)
            }

            // ctx.strokeStyle = "#1d3557";
            // ctx.lineWidth = 20;
            // ctx.beginPath();
            // ctx.moveTo(50, H - 40);
            // ctx.lineTo(20 + 75 * Math.cos(angle), H - 50 + 75 * Math.sin(angle));
            // ctx.stroke();



            // if (shoot) {
            arrows.forEach(arrow => {
                arrow.draw();
                arrow.update();
            })

            
            requestAnimationFrame(render);
        }

        function convertToRad(a) {
            return a / (Math.PI/180)   
        }

        


        class Arrow {
            constructor(vel, angle) {

                this.raius

                this.x = 50 + 75 * Math.cos(angle)			// initial X position 
                this.y = H - 50 + 75 * Math.sin(angle) 	// initial Y position 

                this.A = 0.1 		// acceleration (gravity = 0.1 pixels per frame)
                this.R = 5;

                this.dX = vel/10 * Math.cos(angle) //initial velocity in X
                this.dY = vel/10 * Math.sin(angle)	//initial velocity in Y
            }
            draw() {
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.R, 0, 2 * Math.PI);
                ctx.fill();
            }

            update() {
                // if circle hits the bottom of the Canvas
                if (this.y > H - this.R) {
                    this.y = H - this.R; 
                    this.dX = this.dY = 0; // stop

                }
                else {
                    this.x += this.dX; // update circle X position (uniform motion)
                    this.dY += this.A; // increase circle velocity in Y (accelerated motion)
                    this.y += this.dY; // update circle Y position 
                }
            }
        };



    </script>
</body>
</html>